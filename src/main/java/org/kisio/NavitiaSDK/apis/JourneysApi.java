/*
 * navitia
 *      navitia.io is the open API for building cool stuff with mobility data. It provides the following services      * journeys computation     * line schedules     * next departures     * exploration of public transport data / search places     * and sexy things such as isochrones      navitia is a HATEOAS API that returns JSON formated results     
 *
 * OpenAPI spec version: v2.75.0
 * Contact: navitia@googlegroups.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package org.kisio.NavitiaSDK.apis;

import org.kisio.NavitiaSDK.invokers.ApiCallback;
import org.kisio.NavitiaSDK.invokers.ApiClient;
import org.kisio.NavitiaSDK.invokers.ApiException;
import org.kisio.NavitiaSDK.invokers.ApiResponse;
import org.kisio.NavitiaSDK.invokers.Configuration;
import org.kisio.NavitiaSDK.invokers.Pair;
import org.kisio.NavitiaSDK.invokers.ProgressRequestBody;
import org.kisio.NavitiaSDK.invokers.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import org.joda.time.DateTime;
import org.kisio.NavitiaSDK.models.Journeys;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class JourneysApi {
    private ApiClient apiClient;

    public JourneysApi(String token) throws Exception {
        if (token == null || token.trim().isEmpty()) {
          throw new Exception("Navitia token cannot be empty");
        }
        ApiClient apiClient = new ApiClient();
        apiClient.setUsername(token);
        this.apiClient = apiClient;
    }

    /**
     * Build call for getCoverageLonLatJourneys
     * @param basePath The API base path (optional)
     * @param debugUrl The API Debug url (optional)
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private com.squareup.okhttp.Call getCoverageLonLatJourneysCall(String basePath, String debugUrl, BigDecimal lat, BigDecimal lon, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, Boolean equipmentDetails, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables CC
        String localVarPath = "/coverage/{lon};{lat}/journeys"
            .replaceAll("\\{" + "lat" + "\\}", apiClient.escapePathParam(lat.toString()))
            .replaceAll("\\{" + "lon" + "\\}", apiClient.escapePathParam(lon.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        if (basePath != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "basePath", basePath));
        if (debugUrl != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "debugUrl", debugUrl));
        if (from != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "from", from));
        if (to != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "to", to));
        if (datetime != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime", datetime));
        if (datetimeRepresents != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime_represents", datetimeRepresents));
        if (maxNbTransfers != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_nb_transfers", maxNbTransfers));
        if (minNbTransfers != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "min_nb_transfers", minNbTransfers));
        if (firstSectionMode != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "first_section_mode[]", firstSectionMode));
        if (lastSectionMode != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "last_section_mode[]", lastSectionMode));
        if (maxDurationToPt != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration_to_pt", maxDurationToPt));
        if (maxWalkingDurationToPt != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_walking_duration_to_pt", maxWalkingDurationToPt));
        if (maxBikeDurationToPt != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bike_duration_to_pt", maxBikeDurationToPt));
        if (maxBssDurationToPt != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bss_duration_to_pt", maxBssDurationToPt));
        if (maxCarDurationToPt != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_car_duration_to_pt", maxCarDurationToPt));
        if (maxRidesharingDurationToPt != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_ridesharing_duration_to_pt", maxRidesharingDurationToPt));
        if (walkingSpeed != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "walking_speed", walkingSpeed));
        if (bikeSpeed != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "bike_speed", bikeSpeed));
        if (bssSpeed != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "bss_speed", bssSpeed));
        if (carSpeed != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "car_speed", carSpeed));
        if (ridesharingSpeed != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "ridesharing_speed", ridesharingSpeed));
        if (forbiddenUris != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "forbidden_uris[]", forbiddenUris));
        if (allowedId != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "allowed_id[]", allowedId));
        if (disruptionActive != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "disruption_active", disruptionActive));
        if (dataFreshness != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "data_freshness", dataFreshness));
        if (maxDuration != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration", maxDuration));
        if (wheelchair != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "wheelchair", wheelchair));
        if (travelerType != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "traveler_type", travelerType));
        if (directPath != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "direct_path", directPath));
        if (freeRadiusFrom != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "free_radius_from", freeRadiusFrom));
        if (freeRadiusTo != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "free_radius_to", freeRadiusTo));
        if (count != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "count", count));
        if (isJourneySchedules != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "is_journey_schedules", isJourneySchedules));
        if (minNbJourneys != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "min_nb_journeys", minNbJourneys));
        if (maxNbJourneys != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_nb_journeys", maxNbJourneys));
        if (bssStands != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "bss_stands", bssStands));
        if (addPoiInfos != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "add_poi_infos[]", addPoiInfos));
        if (timeframeDuration != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "timeframe_duration", timeframeDuration));
        if (equipmentDetails != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "equipment_details", equipmentDetails));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getCoverageLonLatJourneysValidateBeforeCall(String basePath, String debugUrl, BigDecimal lat, BigDecimal lon, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, Boolean equipmentDetails, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'lat' is set
        if (lat == null) {
            throw new ApiException("Missing the required parameter 'lat' when calling getCoverageLonLatJourneys(Async)");
        }
        
        // verify the required parameter 'lon' is set
        if (lon == null) {
            throw new ApiException("Missing the required parameter 'lon' when calling getCoverageLonLatJourneys(Async)");
        }
        

        com.squareup.okhttp.Call call = getCoverageLonLatJourneysCall(basePath, debugUrl, lat, lon, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, equipmentDetails, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * 
     * @param basePath The API base path (optional)
     * @param debugUrl The API Debug url (optional)
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @return Journeys
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    protected Journeys getCoverageLonLatJourneys(String basePath, String debugUrl, BigDecimal lat, BigDecimal lon, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, Boolean equipmentDetails) throws ApiException {
        ApiResponse<Journeys> resp = getCoverageLonLatJourneysWithHttpInfo(basePath, debugUrl, lat, lon, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, equipmentDetails);
        return resp.getData();
    }

    /**
     * 
     * 
     * @param basePath The API base path (optional)
     * @param debugUrl The API Debug url (optional)
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @return ApiResponse&lt;Journeys&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    private ApiResponse<Journeys> getCoverageLonLatJourneysWithHttpInfo(String basePath, String debugUrl, BigDecimal lat, BigDecimal lon, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, Boolean equipmentDetails) throws ApiException {
        com.squareup.okhttp.Call call = getCoverageLonLatJourneysValidateBeforeCall(basePath, debugUrl, lat, lon, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, equipmentDetails, null, null);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param basePath The API base path (optional)
     * @param debugUrl The API Debug url (optional)
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getCoverageLonLatJourneysAsync(String basePath, String debugUrl, BigDecimal lat, BigDecimal lon, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, Boolean equipmentDetails, final ApiCallback<Journeys> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageLonLatJourneysValidateBeforeCall(basePath, debugUrl, lat, lon, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, equipmentDetails, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     *  (asynchronously)
     * 
     * @param basePath The API base path (optional)
     * @param debugUrl The API Debug url (optional)
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getCoverageLonLatJourneysAsyncRaw(String basePath, String debugUrl, BigDecimal lat, BigDecimal lon, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, Boolean equipmentDetails, final ApiCallback<String > callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageLonLatJourneysValidateBeforeCall(basePath, debugUrl, lat, lon, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, equipmentDetails, progressListener, progressRequestListener);
        apiClient.executeAsync(call, String.class, callback);
        return call;
    }

    public CoverageLonLatJourneysRequestBuilder newCoverageLonLatJourneysRequestBuilder() {
        return new CoverageLonLatJourneysRequestBuilder(this);
    }

    public class CoverageLonLatJourneysRequestBuilder {
        private JourneysApi currentApi;
        private String basePath;
        private String debugUrl;
        private BigDecimal lat;
        private BigDecimal lon;
        private String from;
        private String to;
        private DateTime datetime;
        private String datetimeRepresents;
        private Integer maxNbTransfers;
        private Integer minNbTransfers;
        private List<String> firstSectionMode;
        private List<String> lastSectionMode;
        private Integer maxDurationToPt;
        private Integer maxWalkingDurationToPt;
        private Integer maxBikeDurationToPt;
        private Integer maxBssDurationToPt;
        private Integer maxCarDurationToPt;
        private Integer maxRidesharingDurationToPt;
        private Float walkingSpeed;
        private Float bikeSpeed;
        private Float bssSpeed;
        private Float carSpeed;
        private Float ridesharingSpeed;
        private List<String> forbiddenUris;
        private List<String> allowedId;
        private Boolean disruptionActive;
        private String dataFreshness;
        private Integer maxDuration;
        private Boolean wheelchair;
        private String travelerType;
        private String directPath;
        private Integer freeRadiusFrom;
        private Integer freeRadiusTo;
        private Integer count;
        private Boolean isJourneySchedules;
        private Integer minNbJourneys;
        private Integer maxNbJourneys;
        private Boolean bssStands;
        private List<String> addPoiInfos;
        private Integer timeframeDuration;
        private Boolean equipmentDetails;

        public CoverageLonLatJourneysRequestBuilder(JourneysApi currentApi) {
            this.currentApi = currentApi;
        }

        public CoverageLonLatJourneysRequestBuilder withBasePath(String basePath) {
            this.basePath = basePath;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withDebugUrl(String debugUrl) {
            this.debugUrl = debugUrl;
            return this;
        }

        public CoverageLonLatJourneysRequestBuilder withLat(BigDecimal lat) {
            this.lat = lat;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withLon(BigDecimal lon) {
            this.lon = lon;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withFrom(String from) {
            this.from = from;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withTo(String to) {
            this.to = to;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withDatetime(DateTime datetime) {
            this.datetime = datetime;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withDatetimeRepresents(String datetimeRepresents) {
            this.datetimeRepresents = datetimeRepresents;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMaxNbTransfers(Integer maxNbTransfers) {
            this.maxNbTransfers = maxNbTransfers;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMinNbTransfers(Integer minNbTransfers) {
            this.minNbTransfers = minNbTransfers;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withFirstSectionMode(List<String> firstSectionMode) {
            this.firstSectionMode = firstSectionMode;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withLastSectionMode(List<String> lastSectionMode) {
            this.lastSectionMode = lastSectionMode;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMaxDurationToPt(Integer maxDurationToPt) {
            this.maxDurationToPt = maxDurationToPt;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMaxWalkingDurationToPt(Integer maxWalkingDurationToPt) {
            this.maxWalkingDurationToPt = maxWalkingDurationToPt;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMaxBikeDurationToPt(Integer maxBikeDurationToPt) {
            this.maxBikeDurationToPt = maxBikeDurationToPt;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMaxBssDurationToPt(Integer maxBssDurationToPt) {
            this.maxBssDurationToPt = maxBssDurationToPt;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMaxCarDurationToPt(Integer maxCarDurationToPt) {
            this.maxCarDurationToPt = maxCarDurationToPt;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMaxRidesharingDurationToPt(Integer maxRidesharingDurationToPt) {
            this.maxRidesharingDurationToPt = maxRidesharingDurationToPt;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withWalkingSpeed(Float walkingSpeed) {
            this.walkingSpeed = walkingSpeed;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withBikeSpeed(Float bikeSpeed) {
            this.bikeSpeed = bikeSpeed;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withBssSpeed(Float bssSpeed) {
            this.bssSpeed = bssSpeed;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withCarSpeed(Float carSpeed) {
            this.carSpeed = carSpeed;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withRidesharingSpeed(Float ridesharingSpeed) {
            this.ridesharingSpeed = ridesharingSpeed;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withForbiddenUris(List<String> forbiddenUris) {
            this.forbiddenUris = forbiddenUris;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withAllowedId(List<String> allowedId) {
            this.allowedId = allowedId;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withDisruptionActive(Boolean disruptionActive) {
            this.disruptionActive = disruptionActive;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withDataFreshness(String dataFreshness) {
            this.dataFreshness = dataFreshness;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMaxDuration(Integer maxDuration) {
            this.maxDuration = maxDuration;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withWheelchair(Boolean wheelchair) {
            this.wheelchair = wheelchair;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withTravelerType(String travelerType) {
            this.travelerType = travelerType;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withDirectPath(String directPath) {
            this.directPath = directPath;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withFreeRadiusFrom(Integer freeRadiusFrom) {
            this.freeRadiusFrom = freeRadiusFrom;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withFreeRadiusTo(Integer freeRadiusTo) {
            this.freeRadiusTo = freeRadiusTo;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withCount(Integer count) {
            this.count = count;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withIsJourneySchedules(Boolean isJourneySchedules) {
            this.isJourneySchedules = isJourneySchedules;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMinNbJourneys(Integer minNbJourneys) {
            this.minNbJourneys = minNbJourneys;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMaxNbJourneys(Integer maxNbJourneys) {
            this.maxNbJourneys = maxNbJourneys;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withBssStands(Boolean bssStands) {
            this.bssStands = bssStands;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withAddPoiInfos(List<String> addPoiInfos) {
            this.addPoiInfos = addPoiInfos;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withTimeframeDuration(Integer timeframeDuration) {
            this.timeframeDuration = timeframeDuration;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withEquipmentDetails(Boolean equipmentDetails) {
            this.equipmentDetails = equipmentDetails;
            return this;
        }

        public com.squareup.okhttp.Call get(final ApiCallback<Journeys > callback) throws ApiException {
            return currentApi.getCoverageLonLatJourneysAsync(basePath, debugUrl, this.lat, this.lon, this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.maxRidesharingDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.ridesharingSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.freeRadiusFrom, this.freeRadiusTo, this.count, this.isJourneySchedules, this.minNbJourneys, this.maxNbJourneys, this.bssStands, this.addPoiInfos, this.timeframeDuration, this.equipmentDetails, callback);
        }

        public com.squareup.okhttp.Call rawGet(final ApiCallback<String > callback) throws ApiException {
            return currentApi.getCoverageLonLatJourneysAsyncRaw(basePath, debugUrl, this.lat, this.lon, this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.maxRidesharingDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.ridesharingSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.freeRadiusFrom, this.freeRadiusTo, this.count, this.isJourneySchedules, this.minNbJourneys, this.maxNbJourneys, this.bssStands, this.addPoiInfos, this.timeframeDuration, this.equipmentDetails, callback);
        }
    }
    /**
     * Build call for getCoverageRegionJourneys
     * @param basePath The API base path (optional)
     * @param debugUrl The API Debug url (optional)
     * @param region  The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private com.squareup.okhttp.Call getCoverageRegionJourneysCall(String basePath, String debugUrl, String region, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, Boolean equipmentDetails, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables CC
        String localVarPath = "/coverage/{region}/journeys"
            .replaceAll("\\{" + "region" + "\\}", apiClient.escapePathParam(region.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        if (basePath != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "basePath", basePath));
        if (debugUrl != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "debugUrl", debugUrl));
        if (from != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "from", from));
        if (to != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "to", to));
        if (datetime != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime", datetime));
        if (datetimeRepresents != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime_represents", datetimeRepresents));
        if (maxNbTransfers != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_nb_transfers", maxNbTransfers));
        if (minNbTransfers != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "min_nb_transfers", minNbTransfers));
        if (firstSectionMode != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "first_section_mode[]", firstSectionMode));
        if (lastSectionMode != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "last_section_mode[]", lastSectionMode));
        if (maxDurationToPt != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration_to_pt", maxDurationToPt));
        if (maxWalkingDurationToPt != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_walking_duration_to_pt", maxWalkingDurationToPt));
        if (maxBikeDurationToPt != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bike_duration_to_pt", maxBikeDurationToPt));
        if (maxBssDurationToPt != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bss_duration_to_pt", maxBssDurationToPt));
        if (maxCarDurationToPt != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_car_duration_to_pt", maxCarDurationToPt));
        if (maxRidesharingDurationToPt != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_ridesharing_duration_to_pt", maxRidesharingDurationToPt));
        if (walkingSpeed != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "walking_speed", walkingSpeed));
        if (bikeSpeed != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "bike_speed", bikeSpeed));
        if (bssSpeed != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "bss_speed", bssSpeed));
        if (carSpeed != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "car_speed", carSpeed));
        if (ridesharingSpeed != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "ridesharing_speed", ridesharingSpeed));
        if (forbiddenUris != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "forbidden_uris[]", forbiddenUris));
        if (allowedId != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "allowed_id[]", allowedId));
        if (disruptionActive != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "disruption_active", disruptionActive));
        if (dataFreshness != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "data_freshness", dataFreshness));
        if (maxDuration != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration", maxDuration));
        if (wheelchair != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "wheelchair", wheelchair));
        if (travelerType != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "traveler_type", travelerType));
        if (directPath != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "direct_path", directPath));
        if (freeRadiusFrom != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "free_radius_from", freeRadiusFrom));
        if (freeRadiusTo != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "free_radius_to", freeRadiusTo));
        if (count != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "count", count));
        if (isJourneySchedules != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "is_journey_schedules", isJourneySchedules));
        if (minNbJourneys != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "min_nb_journeys", minNbJourneys));
        if (maxNbJourneys != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_nb_journeys", maxNbJourneys));
        if (bssStands != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "bss_stands", bssStands));
        if (addPoiInfos != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "add_poi_infos[]", addPoiInfos));
        if (timeframeDuration != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "timeframe_duration", timeframeDuration));
        if (equipmentDetails != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "equipment_details", equipmentDetails));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getCoverageRegionJourneysValidateBeforeCall(String basePath, String debugUrl, String region, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, Boolean equipmentDetails, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'region' is set
        if (region == null) {
            throw new ApiException("Missing the required parameter 'region' when calling getCoverageRegionJourneys(Async)");
        }
        

        com.squareup.okhttp.Call call = getCoverageRegionJourneysCall(basePath, debugUrl, region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, equipmentDetails, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * 
     * @param basePath The API base path (optional)
     * @param debugUrl The API Debug url (optional)
     * @param region  The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @return Journeys
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    protected Journeys getCoverageRegionJourneys(String basePath, String debugUrl, String region, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, Boolean equipmentDetails) throws ApiException {
        ApiResponse<Journeys> resp = getCoverageRegionJourneysWithHttpInfo(basePath, debugUrl, region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, equipmentDetails);
        return resp.getData();
    }

    /**
     * 
     * 
     * @param basePath The API base path (optional)
     * @param debugUrl The API Debug url (optional)
     * @param region  The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @return ApiResponse&lt;Journeys&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    private ApiResponse<Journeys> getCoverageRegionJourneysWithHttpInfo(String basePath, String debugUrl, String region, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, Boolean equipmentDetails) throws ApiException {
        com.squareup.okhttp.Call call = getCoverageRegionJourneysValidateBeforeCall(basePath, debugUrl, region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, equipmentDetails, null, null);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param basePath The API base path (optional)
     * @param debugUrl The API Debug url (optional)
     * @param region  The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getCoverageRegionJourneysAsync(String basePath, String debugUrl, String region, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, Boolean equipmentDetails, final ApiCallback<Journeys> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageRegionJourneysValidateBeforeCall(basePath, debugUrl, region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, equipmentDetails, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     *  (asynchronously)
     * 
     * @param basePath The API base path (optional)
     * @param debugUrl The API Debug url (optional)
     * @param region  The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getCoverageRegionJourneysAsyncRaw(String basePath, String debugUrl, String region, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, Boolean equipmentDetails, final ApiCallback<String > callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageRegionJourneysValidateBeforeCall(basePath, debugUrl, region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, equipmentDetails, progressListener, progressRequestListener);
        apiClient.executeAsync(call, String.class, callback);
        return call;
    }

    public CoverageRegionJourneysRequestBuilder newCoverageRegionJourneysRequestBuilder() {
        return new CoverageRegionJourneysRequestBuilder(this);
    }

    public class CoverageRegionJourneysRequestBuilder {
        private JourneysApi currentApi;
        private String basePath;
        private String debugUrl;
        private String region;
        private String from;
        private String to;
        private DateTime datetime;
        private String datetimeRepresents;
        private Integer maxNbTransfers;
        private Integer minNbTransfers;
        private List<String> firstSectionMode;
        private List<String> lastSectionMode;
        private Integer maxDurationToPt;
        private Integer maxWalkingDurationToPt;
        private Integer maxBikeDurationToPt;
        private Integer maxBssDurationToPt;
        private Integer maxCarDurationToPt;
        private Integer maxRidesharingDurationToPt;
        private Float walkingSpeed;
        private Float bikeSpeed;
        private Float bssSpeed;
        private Float carSpeed;
        private Float ridesharingSpeed;
        private List<String> forbiddenUris;
        private List<String> allowedId;
        private Boolean disruptionActive;
        private String dataFreshness;
        private Integer maxDuration;
        private Boolean wheelchair;
        private String travelerType;
        private String directPath;
        private Integer freeRadiusFrom;
        private Integer freeRadiusTo;
        private Integer count;
        private Boolean isJourneySchedules;
        private Integer minNbJourneys;
        private Integer maxNbJourneys;
        private Boolean bssStands;
        private List<String> addPoiInfos;
        private Integer timeframeDuration;
        private Boolean equipmentDetails;

        public CoverageRegionJourneysRequestBuilder(JourneysApi currentApi) {
            this.currentApi = currentApi;
        }

        public CoverageRegionJourneysRequestBuilder withBasePath(String basePath) {
            this.basePath = basePath;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withDebugUrl(String debugUrl) {
            this.debugUrl = debugUrl;
            return this;
        }

        public CoverageRegionJourneysRequestBuilder withRegion(String region) {
            this.region = region;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withFrom(String from) {
            this.from = from;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withTo(String to) {
            this.to = to;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withDatetime(DateTime datetime) {
            this.datetime = datetime;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withDatetimeRepresents(String datetimeRepresents) {
            this.datetimeRepresents = datetimeRepresents;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMaxNbTransfers(Integer maxNbTransfers) {
            this.maxNbTransfers = maxNbTransfers;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMinNbTransfers(Integer minNbTransfers) {
            this.minNbTransfers = minNbTransfers;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withFirstSectionMode(List<String> firstSectionMode) {
            this.firstSectionMode = firstSectionMode;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withLastSectionMode(List<String> lastSectionMode) {
            this.lastSectionMode = lastSectionMode;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMaxDurationToPt(Integer maxDurationToPt) {
            this.maxDurationToPt = maxDurationToPt;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMaxWalkingDurationToPt(Integer maxWalkingDurationToPt) {
            this.maxWalkingDurationToPt = maxWalkingDurationToPt;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMaxBikeDurationToPt(Integer maxBikeDurationToPt) {
            this.maxBikeDurationToPt = maxBikeDurationToPt;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMaxBssDurationToPt(Integer maxBssDurationToPt) {
            this.maxBssDurationToPt = maxBssDurationToPt;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMaxCarDurationToPt(Integer maxCarDurationToPt) {
            this.maxCarDurationToPt = maxCarDurationToPt;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMaxRidesharingDurationToPt(Integer maxRidesharingDurationToPt) {
            this.maxRidesharingDurationToPt = maxRidesharingDurationToPt;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withWalkingSpeed(Float walkingSpeed) {
            this.walkingSpeed = walkingSpeed;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withBikeSpeed(Float bikeSpeed) {
            this.bikeSpeed = bikeSpeed;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withBssSpeed(Float bssSpeed) {
            this.bssSpeed = bssSpeed;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withCarSpeed(Float carSpeed) {
            this.carSpeed = carSpeed;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withRidesharingSpeed(Float ridesharingSpeed) {
            this.ridesharingSpeed = ridesharingSpeed;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withForbiddenUris(List<String> forbiddenUris) {
            this.forbiddenUris = forbiddenUris;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withAllowedId(List<String> allowedId) {
            this.allowedId = allowedId;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withDisruptionActive(Boolean disruptionActive) {
            this.disruptionActive = disruptionActive;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withDataFreshness(String dataFreshness) {
            this.dataFreshness = dataFreshness;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMaxDuration(Integer maxDuration) {
            this.maxDuration = maxDuration;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withWheelchair(Boolean wheelchair) {
            this.wheelchair = wheelchair;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withTravelerType(String travelerType) {
            this.travelerType = travelerType;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withDirectPath(String directPath) {
            this.directPath = directPath;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withFreeRadiusFrom(Integer freeRadiusFrom) {
            this.freeRadiusFrom = freeRadiusFrom;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withFreeRadiusTo(Integer freeRadiusTo) {
            this.freeRadiusTo = freeRadiusTo;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withCount(Integer count) {
            this.count = count;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withIsJourneySchedules(Boolean isJourneySchedules) {
            this.isJourneySchedules = isJourneySchedules;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMinNbJourneys(Integer minNbJourneys) {
            this.minNbJourneys = minNbJourneys;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMaxNbJourneys(Integer maxNbJourneys) {
            this.maxNbJourneys = maxNbJourneys;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withBssStands(Boolean bssStands) {
            this.bssStands = bssStands;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withAddPoiInfos(List<String> addPoiInfos) {
            this.addPoiInfos = addPoiInfos;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withTimeframeDuration(Integer timeframeDuration) {
            this.timeframeDuration = timeframeDuration;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withEquipmentDetails(Boolean equipmentDetails) {
            this.equipmentDetails = equipmentDetails;
            return this;
        }

        public com.squareup.okhttp.Call get(final ApiCallback<Journeys > callback) throws ApiException {
            return currentApi.getCoverageRegionJourneysAsync(basePath, debugUrl, this.region, this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.maxRidesharingDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.ridesharingSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.freeRadiusFrom, this.freeRadiusTo, this.count, this.isJourneySchedules, this.minNbJourneys, this.maxNbJourneys, this.bssStands, this.addPoiInfos, this.timeframeDuration, this.equipmentDetails, callback);
        }

        public com.squareup.okhttp.Call rawGet(final ApiCallback<String > callback) throws ApiException {
            return currentApi.getCoverageRegionJourneysAsyncRaw(basePath, debugUrl, this.region, this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.maxRidesharingDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.ridesharingSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.freeRadiusFrom, this.freeRadiusTo, this.count, this.isJourneySchedules, this.minNbJourneys, this.maxNbJourneys, this.bssStands, this.addPoiInfos, this.timeframeDuration, this.equipmentDetails, callback);
        }
    }
    /**
     * Build call for getJourneys
     * @param basePath The API base path (optional)
     * @param debugUrl The API Debug url (optional)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private com.squareup.okhttp.Call getJourneysCall(String basePath, String debugUrl, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, Boolean equipmentDetails, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables CC
        String localVarPath = "/journeys";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        if (basePath != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "basePath", basePath));
        if (debugUrl != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "debugUrl", debugUrl));
        if (from != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "from", from));
        if (to != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "to", to));
        if (datetime != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime", datetime));
        if (datetimeRepresents != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime_represents", datetimeRepresents));
        if (maxNbTransfers != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_nb_transfers", maxNbTransfers));
        if (minNbTransfers != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "min_nb_transfers", minNbTransfers));
        if (firstSectionMode != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "first_section_mode[]", firstSectionMode));
        if (lastSectionMode != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "last_section_mode[]", lastSectionMode));
        if (maxDurationToPt != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration_to_pt", maxDurationToPt));
        if (maxWalkingDurationToPt != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_walking_duration_to_pt", maxWalkingDurationToPt));
        if (maxBikeDurationToPt != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bike_duration_to_pt", maxBikeDurationToPt));
        if (maxBssDurationToPt != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bss_duration_to_pt", maxBssDurationToPt));
        if (maxCarDurationToPt != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_car_duration_to_pt", maxCarDurationToPt));
        if (maxRidesharingDurationToPt != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_ridesharing_duration_to_pt", maxRidesharingDurationToPt));
        if (walkingSpeed != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "walking_speed", walkingSpeed));
        if (bikeSpeed != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "bike_speed", bikeSpeed));
        if (bssSpeed != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "bss_speed", bssSpeed));
        if (carSpeed != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "car_speed", carSpeed));
        if (ridesharingSpeed != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "ridesharing_speed", ridesharingSpeed));
        if (forbiddenUris != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "forbidden_uris[]", forbiddenUris));
        if (allowedId != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "allowed_id[]", allowedId));
        if (disruptionActive != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "disruption_active", disruptionActive));
        if (dataFreshness != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "data_freshness", dataFreshness));
        if (maxDuration != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration", maxDuration));
        if (wheelchair != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "wheelchair", wheelchair));
        if (travelerType != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "traveler_type", travelerType));
        if (directPath != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "direct_path", directPath));
        if (freeRadiusFrom != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "free_radius_from", freeRadiusFrom));
        if (freeRadiusTo != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "free_radius_to", freeRadiusTo));
        if (count != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "count", count));
        if (isJourneySchedules != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "is_journey_schedules", isJourneySchedules));
        if (minNbJourneys != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "min_nb_journeys", minNbJourneys));
        if (maxNbJourneys != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_nb_journeys", maxNbJourneys));
        if (bssStands != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "bss_stands", bssStands));
        if (addPoiInfos != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "add_poi_infos[]", addPoiInfos));
        if (timeframeDuration != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "timeframe_duration", timeframeDuration));
        if (equipmentDetails != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "equipment_details", equipmentDetails));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getJourneysValidateBeforeCall(String basePath, String debugUrl, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, Boolean equipmentDetails, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        

        com.squareup.okhttp.Call call = getJourneysCall(basePath, debugUrl, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, equipmentDetails, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * 
     * @param basePath The API base path (optional)
     * @param debugUrl The API Debug url (optional)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @return Journeys
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    protected Journeys getJourneys(String basePath, String debugUrl, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, Boolean equipmentDetails) throws ApiException {
        ApiResponse<Journeys> resp = getJourneysWithHttpInfo(basePath, debugUrl, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, equipmentDetails);
        return resp.getData();
    }

    /**
     * 
     * 
     * @param basePath The API base path (optional)
     * @param debugUrl The API Debug url (optional)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @return ApiResponse&lt;Journeys&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    private ApiResponse<Journeys> getJourneysWithHttpInfo(String basePath, String debugUrl, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, Boolean equipmentDetails) throws ApiException {
        com.squareup.okhttp.Call call = getJourneysValidateBeforeCall(basePath, debugUrl, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, equipmentDetails, null, null);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param basePath The API base path (optional)
     * @param debugUrl The API Debug url (optional)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getJourneysAsync(String basePath, String debugUrl, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, Boolean equipmentDetails, final ApiCallback<Journeys> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getJourneysValidateBeforeCall(basePath, debugUrl, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, equipmentDetails, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     *  (asynchronously)
     * 
     * @param basePath The API base path (optional)
     * @param debugUrl The API Debug url (optional)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getJourneysAsyncRaw(String basePath, String debugUrl, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, Boolean equipmentDetails, final ApiCallback<String > callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getJourneysValidateBeforeCall(basePath, debugUrl, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, equipmentDetails, progressListener, progressRequestListener);
        apiClient.executeAsync(call, String.class, callback);
        return call;
    }

    public JourneysRequestBuilder newJourneysRequestBuilder() {
        return new JourneysRequestBuilder(this);
    }

    public class JourneysRequestBuilder {
        private JourneysApi currentApi;
        private String basePath;
        private String debugUrl;
        private String from;
        private String to;
        private DateTime datetime;
        private String datetimeRepresents;
        private Integer maxNbTransfers;
        private Integer minNbTransfers;
        private List<String> firstSectionMode;
        private List<String> lastSectionMode;
        private Integer maxDurationToPt;
        private Integer maxWalkingDurationToPt;
        private Integer maxBikeDurationToPt;
        private Integer maxBssDurationToPt;
        private Integer maxCarDurationToPt;
        private Integer maxRidesharingDurationToPt;
        private Float walkingSpeed;
        private Float bikeSpeed;
        private Float bssSpeed;
        private Float carSpeed;
        private Float ridesharingSpeed;
        private List<String> forbiddenUris;
        private List<String> allowedId;
        private Boolean disruptionActive;
        private String dataFreshness;
        private Integer maxDuration;
        private Boolean wheelchair;
        private String travelerType;
        private String directPath;
        private Integer freeRadiusFrom;
        private Integer freeRadiusTo;
        private Integer count;
        private Boolean isJourneySchedules;
        private Integer minNbJourneys;
        private Integer maxNbJourneys;
        private Boolean bssStands;
        private List<String> addPoiInfos;
        private Integer timeframeDuration;
        private Boolean equipmentDetails;

        public JourneysRequestBuilder(JourneysApi currentApi) {
            this.currentApi = currentApi;
        }

        public JourneysRequestBuilder withBasePath(String basePath) {
            this.basePath = basePath;
            return this;
        }
        public JourneysRequestBuilder withDebugUrl(String debugUrl) {
            this.debugUrl = debugUrl;
            return this;
        }

        public JourneysRequestBuilder withFrom(String from) {
            this.from = from;
            return this;
        }
        public JourneysRequestBuilder withTo(String to) {
            this.to = to;
            return this;
        }
        public JourneysRequestBuilder withDatetime(DateTime datetime) {
            this.datetime = datetime;
            return this;
        }
        public JourneysRequestBuilder withDatetimeRepresents(String datetimeRepresents) {
            this.datetimeRepresents = datetimeRepresents;
            return this;
        }
        public JourneysRequestBuilder withMaxNbTransfers(Integer maxNbTransfers) {
            this.maxNbTransfers = maxNbTransfers;
            return this;
        }
        public JourneysRequestBuilder withMinNbTransfers(Integer minNbTransfers) {
            this.minNbTransfers = minNbTransfers;
            return this;
        }
        public JourneysRequestBuilder withFirstSectionMode(List<String> firstSectionMode) {
            this.firstSectionMode = firstSectionMode;
            return this;
        }
        public JourneysRequestBuilder withLastSectionMode(List<String> lastSectionMode) {
            this.lastSectionMode = lastSectionMode;
            return this;
        }
        public JourneysRequestBuilder withMaxDurationToPt(Integer maxDurationToPt) {
            this.maxDurationToPt = maxDurationToPt;
            return this;
        }
        public JourneysRequestBuilder withMaxWalkingDurationToPt(Integer maxWalkingDurationToPt) {
            this.maxWalkingDurationToPt = maxWalkingDurationToPt;
            return this;
        }
        public JourneysRequestBuilder withMaxBikeDurationToPt(Integer maxBikeDurationToPt) {
            this.maxBikeDurationToPt = maxBikeDurationToPt;
            return this;
        }
        public JourneysRequestBuilder withMaxBssDurationToPt(Integer maxBssDurationToPt) {
            this.maxBssDurationToPt = maxBssDurationToPt;
            return this;
        }
        public JourneysRequestBuilder withMaxCarDurationToPt(Integer maxCarDurationToPt) {
            this.maxCarDurationToPt = maxCarDurationToPt;
            return this;
        }
        public JourneysRequestBuilder withMaxRidesharingDurationToPt(Integer maxRidesharingDurationToPt) {
            this.maxRidesharingDurationToPt = maxRidesharingDurationToPt;
            return this;
        }
        public JourneysRequestBuilder withWalkingSpeed(Float walkingSpeed) {
            this.walkingSpeed = walkingSpeed;
            return this;
        }
        public JourneysRequestBuilder withBikeSpeed(Float bikeSpeed) {
            this.bikeSpeed = bikeSpeed;
            return this;
        }
        public JourneysRequestBuilder withBssSpeed(Float bssSpeed) {
            this.bssSpeed = bssSpeed;
            return this;
        }
        public JourneysRequestBuilder withCarSpeed(Float carSpeed) {
            this.carSpeed = carSpeed;
            return this;
        }
        public JourneysRequestBuilder withRidesharingSpeed(Float ridesharingSpeed) {
            this.ridesharingSpeed = ridesharingSpeed;
            return this;
        }
        public JourneysRequestBuilder withForbiddenUris(List<String> forbiddenUris) {
            this.forbiddenUris = forbiddenUris;
            return this;
        }
        public JourneysRequestBuilder withAllowedId(List<String> allowedId) {
            this.allowedId = allowedId;
            return this;
        }
        public JourneysRequestBuilder withDisruptionActive(Boolean disruptionActive) {
            this.disruptionActive = disruptionActive;
            return this;
        }
        public JourneysRequestBuilder withDataFreshness(String dataFreshness) {
            this.dataFreshness = dataFreshness;
            return this;
        }
        public JourneysRequestBuilder withMaxDuration(Integer maxDuration) {
            this.maxDuration = maxDuration;
            return this;
        }
        public JourneysRequestBuilder withWheelchair(Boolean wheelchair) {
            this.wheelchair = wheelchair;
            return this;
        }
        public JourneysRequestBuilder withTravelerType(String travelerType) {
            this.travelerType = travelerType;
            return this;
        }
        public JourneysRequestBuilder withDirectPath(String directPath) {
            this.directPath = directPath;
            return this;
        }
        public JourneysRequestBuilder withFreeRadiusFrom(Integer freeRadiusFrom) {
            this.freeRadiusFrom = freeRadiusFrom;
            return this;
        }
        public JourneysRequestBuilder withFreeRadiusTo(Integer freeRadiusTo) {
            this.freeRadiusTo = freeRadiusTo;
            return this;
        }
        public JourneysRequestBuilder withCount(Integer count) {
            this.count = count;
            return this;
        }
        public JourneysRequestBuilder withIsJourneySchedules(Boolean isJourneySchedules) {
            this.isJourneySchedules = isJourneySchedules;
            return this;
        }
        public JourneysRequestBuilder withMinNbJourneys(Integer minNbJourneys) {
            this.minNbJourneys = minNbJourneys;
            return this;
        }
        public JourneysRequestBuilder withMaxNbJourneys(Integer maxNbJourneys) {
            this.maxNbJourneys = maxNbJourneys;
            return this;
        }
        public JourneysRequestBuilder withBssStands(Boolean bssStands) {
            this.bssStands = bssStands;
            return this;
        }
        public JourneysRequestBuilder withAddPoiInfos(List<String> addPoiInfos) {
            this.addPoiInfos = addPoiInfos;
            return this;
        }
        public JourneysRequestBuilder withTimeframeDuration(Integer timeframeDuration) {
            this.timeframeDuration = timeframeDuration;
            return this;
        }
        public JourneysRequestBuilder withEquipmentDetails(Boolean equipmentDetails) {
            this.equipmentDetails = equipmentDetails;
            return this;
        }

        public com.squareup.okhttp.Call get(final ApiCallback<Journeys > callback) throws ApiException {
            return currentApi.getJourneysAsync(basePath, debugUrl, this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.maxRidesharingDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.ridesharingSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.freeRadiusFrom, this.freeRadiusTo, this.count, this.isJourneySchedules, this.minNbJourneys, this.maxNbJourneys, this.bssStands, this.addPoiInfos, this.timeframeDuration, this.equipmentDetails, callback);
        }

        public com.squareup.okhttp.Call rawGet(final ApiCallback<String > callback) throws ApiException {
            return currentApi.getJourneysAsyncRaw(basePath, debugUrl, this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.maxRidesharingDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.ridesharingSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.freeRadiusFrom, this.freeRadiusTo, this.count, this.isJourneySchedules, this.minNbJourneys, this.maxNbJourneys, this.bssStands, this.addPoiInfos, this.timeframeDuration, this.equipmentDetails, callback);
        }
    }
}
