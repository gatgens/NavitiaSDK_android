/*
 * navitia
 *      navitia.io is the open API for building cool stuff with mobility data. It provides the following services      * journeys computation     * line schedules     * next departures     * exploration of public transport data / search places     * and sexy things such as isochrones      navitia is a HATEOAS API that returns JSON formated results     
 *
 * OpenAPI spec version: v2.56.0-81-g74dda6e
 * Contact: navitia@googlegroups.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package org.kisio.NavitiaSDK.apis;

import org.kisio.NavitiaSDK.invokers.ApiCallback;
import org.kisio.NavitiaSDK.invokers.ApiClient;
import org.kisio.NavitiaSDK.invokers.ApiException;
import org.kisio.NavitiaSDK.invokers.ApiResponse;
import org.kisio.NavitiaSDK.invokers.Configuration;
import org.kisio.NavitiaSDK.invokers.Pair;
import org.kisio.NavitiaSDK.invokers.ProgressRequestBody;
import org.kisio.NavitiaSDK.invokers.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import org.joda.time.DateTime;
import org.kisio.NavitiaSDK.models.HeatMap1;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class HeatMapApi {
    private ApiClient apiClient;

    public HeatMapApi(String token) throws Exception {
        if (token == null || token.trim().isEmpty()) {
          throw new Exception("Navitia token cannot be empty");
        }
        ApiClient apiClient = new ApiClient();
        apiClient.setUsername(token);
        this.apiClient = apiClient;
    }

    /**
     * Build call for getCoverageLonLatHeatMaps
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param resolution  (optional, default to 500)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private com.squareup.okhttp.Call getCoverageLonLatHeatMapsCall(BigDecimal lat, BigDecimal lon, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer resolution, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/coverage/{lon};{lat}/heat_maps"
            .replaceAll("\\{" + "lat" + "\\}", apiClient.escapePathParam(lat.toString()))
            .replaceAll("\\{" + "lon" + "\\}", apiClient.escapePathParam(lon.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (from != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "from", from));
        if (to != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "to", to));
        if (datetime != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime", datetime));
        if (datetimeRepresents != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime_represents", datetimeRepresents));
        if (maxNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_nb_transfers", maxNbTransfers));
        if (minNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "min_nb_transfers", minNbTransfers));
        if (firstSectionMode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "first_section_mode[]", firstSectionMode));
        if (lastSectionMode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "last_section_mode[]", lastSectionMode));
        if (maxDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration_to_pt", maxDurationToPt));
        if (maxWalkingDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_walking_duration_to_pt", maxWalkingDurationToPt));
        if (maxBikeDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bike_duration_to_pt", maxBikeDurationToPt));
        if (maxBssDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bss_duration_to_pt", maxBssDurationToPt));
        if (maxCarDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_car_duration_to_pt", maxCarDurationToPt));
        if (maxRidesharingDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_ridesharing_duration_to_pt", maxRidesharingDurationToPt));
        if (walkingSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "walking_speed", walkingSpeed));
        if (bikeSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bike_speed", bikeSpeed));
        if (bssSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bss_speed", bssSpeed));
        if (carSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "car_speed", carSpeed));
        if (ridesharingSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "ridesharing_speed", ridesharingSpeed));
        if (forbiddenUris != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "forbidden_uris[]", forbiddenUris));
        if (allowedId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "allowed_id[]", allowedId));
        if (disruptionActive != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "disruption_active", disruptionActive));
        if (dataFreshness != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "data_freshness", dataFreshness));
        if (maxDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration", maxDuration));
        if (wheelchair != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "wheelchair", wheelchair));
        if (travelerType != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "traveler_type", travelerType));
        if (directPath != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "direct_path", directPath));
        if (freeRadiusFrom != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "free_radius_from", freeRadiusFrom));
        if (freeRadiusTo != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "free_radius_to", freeRadiusTo));
        if (resolution != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "resolution", resolution));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            ""
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getCoverageLonLatHeatMapsValidateBeforeCall(BigDecimal lat, BigDecimal lon, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer resolution, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'lat' is set
        if (lat == null) {
            throw new ApiException("Missing the required parameter 'lat' when calling getCoverageLonLatHeatMaps(Async)");
        }
        
        // verify the required parameter 'lon' is set
        if (lon == null) {
            throw new ApiException("Missing the required parameter 'lon' when calling getCoverageLonLatHeatMaps(Async)");
        }
        

        com.squareup.okhttp.Call call = getCoverageLonLatHeatMapsCall(lat, lon, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, resolution, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * 
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param resolution  (optional, default to 500)
     * @return HeatMap1
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    protected HeatMap1 getCoverageLonLatHeatMaps(BigDecimal lat, BigDecimal lon, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer resolution) throws ApiException {
        ApiResponse<HeatMap1> resp = getCoverageLonLatHeatMapsWithHttpInfo(lat, lon, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, resolution);
        return resp.getData();
    }

    /**
     * 
     * 
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param resolution  (optional, default to 500)
     * @return ApiResponse&lt;HeatMap1&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    private ApiResponse<HeatMap1> getCoverageLonLatHeatMapsWithHttpInfo(BigDecimal lat, BigDecimal lon, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer resolution) throws ApiException {
        com.squareup.okhttp.Call call = getCoverageLonLatHeatMapsValidateBeforeCall(lat, lon, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, resolution, null, null);
        Type localVarReturnType = new TypeToken<HeatMap1>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param resolution  (optional, default to 500)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getCoverageLonLatHeatMapsAsync(BigDecimal lat, BigDecimal lon, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer resolution, final ApiCallback<HeatMap1> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageLonLatHeatMapsValidateBeforeCall(lat, lon, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, resolution, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<HeatMap1>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     *  (asynchronously)
     * 
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param resolution  (optional, default to 500)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getCoverageLonLatHeatMapsAsyncRaw(BigDecimal lat, BigDecimal lon, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer resolution, final ApiCallback<String > callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageLonLatHeatMapsValidateBeforeCall(lat, lon, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, resolution, progressListener, progressRequestListener);
        apiClient.executeAsync(call, String.class, callback);
        return call;
    }

    public CoverageLonLatHeatMapsRequestBuilder newCoverageLonLatHeatMapsRequestBuilder() {
        return new CoverageLonLatHeatMapsRequestBuilder(this);
    }

    public class CoverageLonLatHeatMapsRequestBuilder {
        private HeatMapApi currentApi;
        private BigDecimal lat;
        private BigDecimal lon;
        private String from;
        private String to;
        private DateTime datetime;
        private String datetimeRepresents;
        private Integer maxNbTransfers;
        private Integer minNbTransfers;
        private List<String> firstSectionMode;
        private List<String> lastSectionMode;
        private Integer maxDurationToPt;
        private Integer maxWalkingDurationToPt;
        private Integer maxBikeDurationToPt;
        private Integer maxBssDurationToPt;
        private Integer maxCarDurationToPt;
        private Integer maxRidesharingDurationToPt;
        private Float walkingSpeed;
        private Float bikeSpeed;
        private Float bssSpeed;
        private Float carSpeed;
        private Float ridesharingSpeed;
        private List<String> forbiddenUris;
        private List<String> allowedId;
        private Boolean disruptionActive;
        private String dataFreshness;
        private Integer maxDuration;
        private Boolean wheelchair;
        private String travelerType;
        private String directPath;
        private Integer freeRadiusFrom;
        private Integer freeRadiusTo;
        private Integer resolution;

        public CoverageLonLatHeatMapsRequestBuilder(HeatMapApi currentApi) {
            this.currentApi = currentApi;
        }

        public CoverageLonLatHeatMapsRequestBuilder withLat(BigDecimal lat) {
            this.lat = lat;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withLon(BigDecimal lon) {
            this.lon = lon;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withFrom(String from) {
            this.from = from;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withTo(String to) {
            this.to = to;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withDatetime(DateTime datetime) {
            this.datetime = datetime;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withDatetimeRepresents(String datetimeRepresents) {
            this.datetimeRepresents = datetimeRepresents;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withMaxNbTransfers(Integer maxNbTransfers) {
            this.maxNbTransfers = maxNbTransfers;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withMinNbTransfers(Integer minNbTransfers) {
            this.minNbTransfers = minNbTransfers;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withFirstSectionMode(List<String> firstSectionMode) {
            this.firstSectionMode = firstSectionMode;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withLastSectionMode(List<String> lastSectionMode) {
            this.lastSectionMode = lastSectionMode;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withMaxDurationToPt(Integer maxDurationToPt) {
            this.maxDurationToPt = maxDurationToPt;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withMaxWalkingDurationToPt(Integer maxWalkingDurationToPt) {
            this.maxWalkingDurationToPt = maxWalkingDurationToPt;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withMaxBikeDurationToPt(Integer maxBikeDurationToPt) {
            this.maxBikeDurationToPt = maxBikeDurationToPt;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withMaxBssDurationToPt(Integer maxBssDurationToPt) {
            this.maxBssDurationToPt = maxBssDurationToPt;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withMaxCarDurationToPt(Integer maxCarDurationToPt) {
            this.maxCarDurationToPt = maxCarDurationToPt;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withMaxRidesharingDurationToPt(Integer maxRidesharingDurationToPt) {
            this.maxRidesharingDurationToPt = maxRidesharingDurationToPt;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withWalkingSpeed(Float walkingSpeed) {
            this.walkingSpeed = walkingSpeed;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withBikeSpeed(Float bikeSpeed) {
            this.bikeSpeed = bikeSpeed;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withBssSpeed(Float bssSpeed) {
            this.bssSpeed = bssSpeed;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withCarSpeed(Float carSpeed) {
            this.carSpeed = carSpeed;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withRidesharingSpeed(Float ridesharingSpeed) {
            this.ridesharingSpeed = ridesharingSpeed;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withForbiddenUris(List<String> forbiddenUris) {
            this.forbiddenUris = forbiddenUris;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withAllowedId(List<String> allowedId) {
            this.allowedId = allowedId;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withDisruptionActive(Boolean disruptionActive) {
            this.disruptionActive = disruptionActive;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withDataFreshness(String dataFreshness) {
            this.dataFreshness = dataFreshness;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withMaxDuration(Integer maxDuration) {
            this.maxDuration = maxDuration;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withWheelchair(Boolean wheelchair) {
            this.wheelchair = wheelchair;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withTravelerType(String travelerType) {
            this.travelerType = travelerType;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withDirectPath(String directPath) {
            this.directPath = directPath;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withFreeRadiusFrom(Integer freeRadiusFrom) {
            this.freeRadiusFrom = freeRadiusFrom;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withFreeRadiusTo(Integer freeRadiusTo) {
            this.freeRadiusTo = freeRadiusTo;
            return this;
        }
        public CoverageLonLatHeatMapsRequestBuilder withResolution(Integer resolution) {
            this.resolution = resolution;
            return this;
        }

        public com.squareup.okhttp.Call get(final ApiCallback<HeatMap1 > callback) throws ApiException {
            return currentApi.getCoverageLonLatHeatMapsAsync(this.lat, this.lon, this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.maxRidesharingDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.ridesharingSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.freeRadiusFrom, this.freeRadiusTo, this.resolution, callback);
        }

        public com.squareup.okhttp.Call rawGet(final ApiCallback<String > callback) throws ApiException {
            return currentApi.getCoverageLonLatHeatMapsAsyncRaw(this.lat, this.lon, this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.maxRidesharingDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.ridesharingSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.freeRadiusFrom, this.freeRadiusTo, this.resolution, callback);
        }
    }
    /**
     * Build call for getCoverageRegionHeatMaps
     * @param region  The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param resolution  (optional, default to 500)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private com.squareup.okhttp.Call getCoverageRegionHeatMapsCall(String region, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer resolution, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/coverage/{region}/heat_maps"
            .replaceAll("\\{" + "region" + "\\}", apiClient.escapePathParam(region.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (from != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "from", from));
        if (to != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "to", to));
        if (datetime != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime", datetime));
        if (datetimeRepresents != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime_represents", datetimeRepresents));
        if (maxNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_nb_transfers", maxNbTransfers));
        if (minNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "min_nb_transfers", minNbTransfers));
        if (firstSectionMode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "first_section_mode[]", firstSectionMode));
        if (lastSectionMode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "last_section_mode[]", lastSectionMode));
        if (maxDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration_to_pt", maxDurationToPt));
        if (maxWalkingDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_walking_duration_to_pt", maxWalkingDurationToPt));
        if (maxBikeDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bike_duration_to_pt", maxBikeDurationToPt));
        if (maxBssDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bss_duration_to_pt", maxBssDurationToPt));
        if (maxCarDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_car_duration_to_pt", maxCarDurationToPt));
        if (maxRidesharingDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_ridesharing_duration_to_pt", maxRidesharingDurationToPt));
        if (walkingSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "walking_speed", walkingSpeed));
        if (bikeSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bike_speed", bikeSpeed));
        if (bssSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bss_speed", bssSpeed));
        if (carSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "car_speed", carSpeed));
        if (ridesharingSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "ridesharing_speed", ridesharingSpeed));
        if (forbiddenUris != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "forbidden_uris[]", forbiddenUris));
        if (allowedId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "allowed_id[]", allowedId));
        if (disruptionActive != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "disruption_active", disruptionActive));
        if (dataFreshness != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "data_freshness", dataFreshness));
        if (maxDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration", maxDuration));
        if (wheelchair != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "wheelchair", wheelchair));
        if (travelerType != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "traveler_type", travelerType));
        if (directPath != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "direct_path", directPath));
        if (freeRadiusFrom != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "free_radius_from", freeRadiusFrom));
        if (freeRadiusTo != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "free_radius_to", freeRadiusTo));
        if (resolution != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "resolution", resolution));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            ""
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getCoverageRegionHeatMapsValidateBeforeCall(String region, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer resolution, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'region' is set
        if (region == null) {
            throw new ApiException("Missing the required parameter 'region' when calling getCoverageRegionHeatMaps(Async)");
        }
        

        com.squareup.okhttp.Call call = getCoverageRegionHeatMapsCall(region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, resolution, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * 
     * @param region  The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param resolution  (optional, default to 500)
     * @return HeatMap1
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    protected HeatMap1 getCoverageRegionHeatMaps(String region, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer resolution) throws ApiException {
        ApiResponse<HeatMap1> resp = getCoverageRegionHeatMapsWithHttpInfo(region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, resolution);
        return resp.getData();
    }

    /**
     * 
     * 
     * @param region  The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param resolution  (optional, default to 500)
     * @return ApiResponse&lt;HeatMap1&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    private ApiResponse<HeatMap1> getCoverageRegionHeatMapsWithHttpInfo(String region, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer resolution) throws ApiException {
        com.squareup.okhttp.Call call = getCoverageRegionHeatMapsValidateBeforeCall(region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, resolution, null, null);
        Type localVarReturnType = new TypeToken<HeatMap1>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param region  The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param resolution  (optional, default to 500)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getCoverageRegionHeatMapsAsync(String region, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer resolution, final ApiCallback<HeatMap1> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageRegionHeatMapsValidateBeforeCall(region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, resolution, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<HeatMap1>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     *  (asynchronously)
     * 
     * @param region  The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param resolution  (optional, default to 500)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getCoverageRegionHeatMapsAsyncRaw(String region, String from, String to, DateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, Integer resolution, final ApiCallback<String > callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageRegionHeatMapsValidateBeforeCall(region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, resolution, progressListener, progressRequestListener);
        apiClient.executeAsync(call, String.class, callback);
        return call;
    }

    public CoverageRegionHeatMapsRequestBuilder newCoverageRegionHeatMapsRequestBuilder() {
        return new CoverageRegionHeatMapsRequestBuilder(this);
    }

    public class CoverageRegionHeatMapsRequestBuilder {
        private HeatMapApi currentApi;
        private String region;
        private String from;
        private String to;
        private DateTime datetime;
        private String datetimeRepresents;
        private Integer maxNbTransfers;
        private Integer minNbTransfers;
        private List<String> firstSectionMode;
        private List<String> lastSectionMode;
        private Integer maxDurationToPt;
        private Integer maxWalkingDurationToPt;
        private Integer maxBikeDurationToPt;
        private Integer maxBssDurationToPt;
        private Integer maxCarDurationToPt;
        private Integer maxRidesharingDurationToPt;
        private Float walkingSpeed;
        private Float bikeSpeed;
        private Float bssSpeed;
        private Float carSpeed;
        private Float ridesharingSpeed;
        private List<String> forbiddenUris;
        private List<String> allowedId;
        private Boolean disruptionActive;
        private String dataFreshness;
        private Integer maxDuration;
        private Boolean wheelchair;
        private String travelerType;
        private String directPath;
        private Integer freeRadiusFrom;
        private Integer freeRadiusTo;
        private Integer resolution;

        public CoverageRegionHeatMapsRequestBuilder(HeatMapApi currentApi) {
            this.currentApi = currentApi;
        }

        public CoverageRegionHeatMapsRequestBuilder withRegion(String region) {
            this.region = region;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withFrom(String from) {
            this.from = from;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withTo(String to) {
            this.to = to;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withDatetime(DateTime datetime) {
            this.datetime = datetime;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withDatetimeRepresents(String datetimeRepresents) {
            this.datetimeRepresents = datetimeRepresents;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withMaxNbTransfers(Integer maxNbTransfers) {
            this.maxNbTransfers = maxNbTransfers;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withMinNbTransfers(Integer minNbTransfers) {
            this.minNbTransfers = minNbTransfers;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withFirstSectionMode(List<String> firstSectionMode) {
            this.firstSectionMode = firstSectionMode;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withLastSectionMode(List<String> lastSectionMode) {
            this.lastSectionMode = lastSectionMode;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withMaxDurationToPt(Integer maxDurationToPt) {
            this.maxDurationToPt = maxDurationToPt;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withMaxWalkingDurationToPt(Integer maxWalkingDurationToPt) {
            this.maxWalkingDurationToPt = maxWalkingDurationToPt;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withMaxBikeDurationToPt(Integer maxBikeDurationToPt) {
            this.maxBikeDurationToPt = maxBikeDurationToPt;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withMaxBssDurationToPt(Integer maxBssDurationToPt) {
            this.maxBssDurationToPt = maxBssDurationToPt;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withMaxCarDurationToPt(Integer maxCarDurationToPt) {
            this.maxCarDurationToPt = maxCarDurationToPt;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withMaxRidesharingDurationToPt(Integer maxRidesharingDurationToPt) {
            this.maxRidesharingDurationToPt = maxRidesharingDurationToPt;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withWalkingSpeed(Float walkingSpeed) {
            this.walkingSpeed = walkingSpeed;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withBikeSpeed(Float bikeSpeed) {
            this.bikeSpeed = bikeSpeed;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withBssSpeed(Float bssSpeed) {
            this.bssSpeed = bssSpeed;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withCarSpeed(Float carSpeed) {
            this.carSpeed = carSpeed;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withRidesharingSpeed(Float ridesharingSpeed) {
            this.ridesharingSpeed = ridesharingSpeed;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withForbiddenUris(List<String> forbiddenUris) {
            this.forbiddenUris = forbiddenUris;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withAllowedId(List<String> allowedId) {
            this.allowedId = allowedId;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withDisruptionActive(Boolean disruptionActive) {
            this.disruptionActive = disruptionActive;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withDataFreshness(String dataFreshness) {
            this.dataFreshness = dataFreshness;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withMaxDuration(Integer maxDuration) {
            this.maxDuration = maxDuration;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withWheelchair(Boolean wheelchair) {
            this.wheelchair = wheelchair;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withTravelerType(String travelerType) {
            this.travelerType = travelerType;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withDirectPath(String directPath) {
            this.directPath = directPath;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withFreeRadiusFrom(Integer freeRadiusFrom) {
            this.freeRadiusFrom = freeRadiusFrom;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withFreeRadiusTo(Integer freeRadiusTo) {
            this.freeRadiusTo = freeRadiusTo;
            return this;
        }
        public CoverageRegionHeatMapsRequestBuilder withResolution(Integer resolution) {
            this.resolution = resolution;
            return this;
        }

        public com.squareup.okhttp.Call get(final ApiCallback<HeatMap1 > callback) throws ApiException {
            return currentApi.getCoverageRegionHeatMapsAsync(this.region, this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.maxRidesharingDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.ridesharingSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.freeRadiusFrom, this.freeRadiusTo, this.resolution, callback);
        }

        public com.squareup.okhttp.Call rawGet(final ApiCallback<String > callback) throws ApiException {
            return currentApi.getCoverageRegionHeatMapsAsyncRaw(this.region, this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.maxRidesharingDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.ridesharingSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.freeRadiusFrom, this.freeRadiusTo, this.resolution, callback);
        }
    }
}
